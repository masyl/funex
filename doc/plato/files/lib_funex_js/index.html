<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap-3.0.0-wip.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lib/funex.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="span6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">45.78</p>
    </div>
    <div class="span6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">342</p>
    </div>
  </div>
  <div class="row historical">
    <div class="span6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="span6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="span6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">81.89</p>
    </div>
    <div class="span6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">2.76</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="span6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="span6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="span12">(function (global) {
	"use strict";
	var undef = void 0;
	// Declare constants for state names
	var __default = 99;
	var __callOpen = 3;
	var __callClose = 4;
	var __arrayOpen = 5;
	var __arrayClose = 6;
	var __dot = 7;
	var __argsSeparator = 8;
	var __whitespace = 9;
	var __string = 10;
	var __numeric = 11;
	var __name = 12;
	var __statementSeparator = 13;
	var __charMapNumericStart = "1234567890-";
	var __charMapWhiteSpace = " \n\t";
	var __charMapNumeric = __charMapNumericStart + ".";
	var __charMapAlpha = "abcdefghijklmnopqrstuvwxyz";
	var __charMapAlphaExtended = __charMapAlpha + __charMapAlpha.toUpperCase() + "_$";
	var __charMapAlphaExtendedContinued = __charMapAlphaExtended + __charMapNumericStart;
	var stateChars = {
		"(":__callOpen,
		")":__callClose,
		"[":__arrayOpen,
		"]":__arrayClose,
		".":__dot,
		",":__argsSeparator,
		" ":__whitespace,
		"\n":__whitespace,
		"\t":__whitespace,
		"'":__string,
		";":__statementSeparator
	};


	/**
	 * Takes an array of objects and creates a prototype chain
	 * that can simulate a stack of memory frames
	 * @param framesArray An array of objects to be used as memory frames
	 */
	function recursiveMemoryFrameFactory(framesArray) {
		// Ensure that the provided array will not be muted during
		// the recursions
		function _recursiveMemoryFrameFactory(framesArray) {
			function Frame(obj) {
				for (var key in obj) {
					if (obj.hasOwnProperty(key)) {
						this[key] = obj[key];
					}
				}
			}
			var referenceObj = framesArray.shift();
			if (framesArray.length > 0) {
				Frame.prototype = _recursiveMemoryFrameFactory(framesArray);
			}
			var frame = new Frame(referenceObj);
			return frame;
		}
		return _recursiveMemoryFrameFactory(framesArray.slice(0));
	}


	/**
	 * Compile a funex string expression into a executable function
	 * @param exp
	 */
	function compile(exp) {
		//get rid of leading and trailing spaces.
		exp = exp.trim();
		var tokens = tokenizer(exp);
		return function (context) {
			// If no context was provided, create an empty one.
			if (typeof context === "undefined") context = [
				{}
			];
			//If the context is not already an array, create a one-level stack
			if (context.constructor.name !== "Array") context = [context];

			// var frames = context;
			var frames = [recursiveMemoryFrameFactory(context)];

			return executeTokens(tokens, frames);
		};
	}

	if (typeof module == "object" && typeof window == "undefined") module.exports = compile;
	if (typeof window == "object" && global === window) window.funex = compile;

	/**
	 * Execute the instructions dictated by code tokens
	 * @param tokens
	 * @param context
	 */
	function executeTokens(tokens, context) {
		var i;
		var j;
		var s0; // Shorthand for the first item of the call stack
		var token;
		var tokenStr;
		var args;
		var frame;
		var value = undef;
		var valueParent = context[0];
		var state;
		var callee;
		var parsedStr = "";
		var stack = [
			[context[0]] //todo: array encapsulation not needed anymore since we simulate the call stack with the prototype chain
		];
		stack[0].d = false; // Set the current context as no dirty 
		var __function = "function";
		var __illegalCall = "Illegal call : ";
		var __syntaxError = "Syntax error : ";
		var statementOutputs = [];

		for (i = 0; i < tokens.length; i++) {
			s0 = stack[0];
			token = tokens[i];
			tokenStr = token[0];
			state = token[1];
			parsedStr += tokenStr;
			switch (state) {
				case __default:
					throw __syntaxError + parsedStr;
				case  __callOpen:
					s0.d = true; // Mark the context as dirty
					// Add a fresh context in the stack
					args = [context[0]];
					args._ = true; // Mark the statement as unterminated
					args.c = value; // Callee
					args.cP = valueParent; // CalleeParent
					args.d = false; // Start as not dirty
					stack.unshift(args);
					value = undef;
					valueParent = context[0];
					break;
				case __callClose:
					// Pop the stack and then call the new stack head
					// with the popped value
					args = stack.shift();
					callee = args.c;
					if (!args._)
						throw __syntaxError + __illegalCall + parsedStr;
					if (callee !== context[0]) { // Prevent an array call on undefined
						// Reverse the argument into the correct order
						if (typeof callee !== __function)
							throw "Type error: " + typeof(callee) + " is not a " + __function + " : " + parsedStr;
						stack[0][0] = callee.apply(args.cP, args.reverse());
						value = stack[0][0];
						s0 = stack[0];
						s0.d = true; // Mark the context as dirty
					} else
						throw __syntaxError + __illegalCall + parsedStr;
					break;
				case __arrayOpen:
					s0.d = true; // Mark the context as dirty
					stack.unshift([context[0]]);
					value = undef;
					valueParent = context[0];
					break;
				case __arrayClose:
					// Pop the stack and then call the new stack head
					// as an array with the popped value
					value = stack.shift();
					s0 = stack[0];
					s0.d = true; // Mark the context as dirty
					// Prevent an array call on the root context
					if (s0[0] === context[0])
						throw __syntaxError + __illegalCall + parsedStr;
					// Prevent an array call on undefined
					if (s0[0] === undef)
						throw "Cannot read property '" + tokenStr + "' of undefined : " + parsedStr;
					// Read the new value
					value = s0[0][ value[0] ];
					s0[0] = value;
					break;
				case __dot:
					s0.d = true; // Mark the context as dirty
					valueParent = value;
					value = undef;
					break;
				case __argsSeparator:
					s0.d = true; // Mark the context as dirty
					//todo: check if the argSeparator is used in a correct setting
					if (!s0._)
						throw __syntaxError + parsedStr;
					value = undef;
					valueParent = context[0];
					// If the first argument was never set, set as undefined
					if (s0[0] === context[0])
						s0[0] = undef;
					s0.unshift(context[0]);
					break;
				case __string:
					s0.d = true; // Mark the context as dirty
					s0[0] = value = tokenStr;
					break;
				case __numeric:
					s0.d = true; // Mark the context as dirty
					s0[0] = value = parseFloat(tokenStr);
					break;
				case __name:
					s0.d = true; // Mark the context as dirty
					// Else resolve it on the current value
					if (s0[0] === undef)
						throw "Cannot read property '" + tokenStr + "' of undefined : " + parsedStr;
					value = s0[0][tokenStr];
					s0[0] = value;
					break;
				case __statementSeparator:
					//todo: check if the argSeparator is used in a correct setting (unterminated statement)
					if (s0._)
						throw __syntaxError + parsedStr;
					// If a new context is dirty (statement has been started)
					// Store the current value as a candidate for output
					if (s0.d) statementOutputs.unshift(value); 
					s0.d = false;
					// Clear the context and values
					s0[0] = context[0];
					valueParent = undef;
					value = undef;
			}
		}
		s0 = stack[0];
		// If a new context is dirty (statement has been started)
		// Store the current value as a candidate for output
		if (s0.d) statementOutputs.unshift(value);
		return (statementOutputs.length) ? statementOutputs[0] : undef;
	}

	/**
	 * Parse a funex string into a stack of tokens
	 * @param exp
	 */
	function tokenizer(exp) {
		var i;
		var chr;
		var instructions = [];
		var newState;
		var token = "";
		var state = __default;
		var tokenIsOneChar;

		//special case for "''"
		if (exp === "''"){
			instructions.push(["", __string]);
			return instructions;
		}

		for (i = 0; i < exp.length; i++) {
			chr = exp[i];
			newState = undef;
			tokenIsOneChar = (token.length == 1);
			switch (state) {
				case __default:
					newState = stateChars[chr];
					if (newState !== undef) break;
					if (__charMapNumericStart.indexOf(chr) + 1) {
						newState = __numeric;
						break;
					}
					if (__charMapAlphaExtended.indexOf(chr) + 1)
						newState = __name;
					break;
				case  __callOpen:
					if (chr != "(" || tokenIsOneChar) newState = __default;
					break;
				case __callClose:
					if (chr != ")" || tokenIsOneChar) newState = __default;
					break;
				case __arrayOpen:
					if (chr != "[" || tokenIsOneChar) newState = __default;
					break;
				case __arrayClose:
					if (chr != "]" || tokenIsOneChar) newState = __default;
					break;
				case __statementSeparator:
					if (chr != ";" || tokenIsOneChar) newState = __default;
					break;
				case __dot:
					if (chr != "." || tokenIsOneChar) newState = __default;
					break;
				case __argsSeparator:
					if (chr != "," || tokenIsOneChar) newState = __default;
					break;
				case __whitespace:
					// todo: add other whitespace codes
					if (__charMapWhiteSpace.indexOf(chr) < 0) newState = __default;
					break;
				case __string:
					// If the last char is a "'""
					if (chr == "'") {
						//if the character is a "'" and is preceeded by a "\\", then we
						//update the token and keep going (we remove the escaping)
						if ((token.length > 1 || token === "'") && exp[i-1] === "\\" ) {
							token = token.substring(0,token.length-1);
						}
						// If the last char is a "'" and not the first char
						else if (token.length > 1) {
							token = token.substring(1);
							chr = "";
							newState = __default;
						}
					}
					break;
				case __numeric:
					if (__charMapNumeric.indexOf(chr) < 0)
						newState = __default;
					break;
				case __name:
					if (__charMapAlphaExtendedContinued.indexOf(chr) < 0)
						newState = __default;
			}

			// If state changed, set the new state push the token on the
			// stack of tokens and start a new token
			if (newState) {
				// If the current token is not empty,
				// push it in the instruction stack
				if (token.length)
					instructions.push([token, state]);
				// Get the new state returned by the state handler
				state = newState;
				// Flush the token
				token = "";
				// Unless the current character has been flushed (like for quotes
				// around strings, set back the index for the next iteration
				if (chr !== "") i--;
			} else {
				// Push the parsing result of that char on the token
				token += chr;
			}
		}
		// Push the last token
		if (token.length){
			instructions.push([token, state]);
		}
		return instructions;
	}
})(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
